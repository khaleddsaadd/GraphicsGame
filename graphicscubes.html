<canvas id="scene"></canvas>
<script src="lib/three.min.js"></script>
<script src="lib/OrbitControls.js"></script>
<html>
    <body>
        <h1>Score: <span id="myText"></span></h1>
    </body>
</html>
<script>

var ww = 2000,
wh = 700;
var usePres = true;
var scene;
var cubearr = [];
var k=0.02;
var fo2=60;
var count=0;
function init()
{



var renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(ww, wh);
renderer.setClearColor(0xFFFFFF, 1);

document.body.appendChild(renderer.domElement);

 scene = new THREE.Scene();

var camera = new THREE.PerspectiveCamera(40, ww/wh,1,1000);
camera.position.z =  100;
camera.position.y = 5;    
camera.name = 'cam';
camera.lookAt(new THREE.Vector3(0,0,0));

scene.add(camera);

    
    const light = new THREE.PointLight( 0xFFFFFF, 1, 10000 );
light.position.set( 0, 20, 50 );
    light.name = 'light';
scene.add( light );
    const loader = new THREE.CubeTextureLoader();
loader.setPath( 'C:/xampp/htdocs/graphics/' );


    var texture1 = new THREE.TextureLoader().load('texturefloor.jpg');
texture1.wrapS = THREE.RepeatWrapping;
texture1.wrapT = THREE.RepeatWrapping;
texture1.repeat.set( 100, 10 );
var material1 = new THREE.MeshBasicMaterial( { map: texture1 } );
    
    
    var texture2 = new THREE.TextureLoader().load('spheretex.jpg');
    var material2 = new THREE.MeshBasicMaterial( { map: texture2 } );
var sphereG =  new THREE.SphereGeometry(4, 100, 100, 0, Math.PI * 2, 0, Math.PI * 2);
        var spherem = new THREE.MeshLambertMaterial({color: 0xff2255});
        var sphere = new THREE.Mesh(sphereG, material2);
    sphere.position.y = -12;
        sphere.name = 'sp';
        scene.add(sphere);
    
    const geometry = new THREE.BoxGeometry( 100, 5, 10 );
const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
const cube = new THREE.Mesh( geometry, material1 );
    cube.position.y = -20;
scene.add( cube );





createCubes();

function render() 
{
    requestAnimationFrame(render);
    for(var i=0; i<cubearr.length ;i++ )
        {
                cubearr[i].position.y -= Math.random();
        }
       
        
    renderer.render(scene, camera);
}
    function moveCube(e) 
    {
       var moveDistance = 0.30;
        var sp = scene.getObjectByName('sp');
        var cam = scene.getObjectByName('cam');
        var light = scene.getObjectByName('light');
        if (e.keyCode == '39') 
        {
            if(sp.position.x < 48)
                {
                    
            sp.rotation.z -= moveDistance;
            sp.position.x += 3;
            light.position.x += 3;
            count++;
         document.getElementById("myText").innerHTML = count;
                }
            
          
        } 
        
        else if (e.keyCode == '37')
    
        {
            if(sp.position.x > -48)
                {
          sp.rotation.z += moveDistance;
            sp.position.x-= 3;
            light.position.x -= 3;
            count++;
         document.getElementById("myText").innerHTML = count;
                    
                }
        } 
       
       
    };
      window.addEventListener("keydown", moveCube);
render();
};

function createCubes()
{
    var geometry2 = new THREE.BoxGeometry(5,5,5);
    texture = new THREE.TextureLoader().load( '25649.jpg' );
        materialtex = new THREE.MeshBasicMaterial( { map: texture } );
    var max=48 , min=-48;
    for (let i = 0; i < 1000; i++) 
    {
        cubearr[i] = new THREE.Mesh(geometry2, materialtex);
        cubearr[i].position.x =(Math.random() * (max - min)) + min;
        cubearr[i].position.y = fo2;
        fo2 = fo2+10;
        scene.add(cubearr[i]);
    }

}

    
init();
    </script>
   